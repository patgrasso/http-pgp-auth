# HTTP PGP Authentication: Threat Model

This document attempts to define a threat model for the HTTP PGP Authentication
strategy. While most of the heavy lifting is outsourced to more capable tools
and protocols with their own security concerns, this protocol's interactions
with those tools/protocols create avenues for attack that must be carefully
protected.

We will use the term HPGA to refer to HTTP PGP Authentication (although the
acronym HPGA stands for (H)TTP (P)retty (G)ood (A)uthentication, these all
refer to the same protocol).

## Challenge-Response over HTTP

### Challenges

The challenge is a hexidecimal representation of a sequence of randomly chosen
bytes that are assumed to be difficult for an attacker to guess. This challenge
is generated by the server and issued with the `WWW-Authenticate` HTTP header.
Challenges may never be reused, as this would leave the protocol vulnerable to
replay attacks, in which an attacker watching the traffic between the client
and the server could capture a client's response to a challenge, which may
contain a valid signature from the client, and use the same signature in a
subsequent request to obtain a session cookie or restricted resources from the
server.

This challenge-response protocol requires the server to maintain a set of
valid challenges that it has issued. No additional information needs to stored
with the challenges, and they need not be ordered or bound to the users to whom
they are issued. All of the information necessary for authenticating a user
will be present in the client's signature of this challenge, and so challenges
themselves do not pose a significant risk for false authorization.

In order to mitigate the risk of challenge re-use and potential memory
exhaustion, servers implementing HPGA should consider associating a timeout
with each challenge which invalides the challenge after some time, or keeping
challenges in a fixed-size queue so that old, unused challenges are discarded.

### Responses

The response consists of an empty-bodied POST request to the same URL that
issued the challenge. This request will set the `Authorization` header, whose
value will consist of the string "PGP" followed by a space, then the
ASCII-armored PGP message containing the client's signature, the challenge, and
the key ID which was used to sign the challenge. This is equivalent to the
output of `gpg -s`.

This information alone _may_ be used to identify the user
who provided the signature, as the public key component of the key pair used to
sign the challenge may be searchable on a PGP key server. Information such as
names and email addresses are often associated with public keys, and so the
exposure of this information poses a risk to users' privacy. For instance, an
attacker observing traffic to and from the server can observe all challenge
signatures crafted by clients in response to challenges, collect the key IDs
contained within these signature messages, and search for the owner of the key
on a public key server. This would allow the attacker to learn who is accessing
the server/service and when they authenticate.

The security of a signature itself is directly dependent on the cryptographic
algorithms used for key generation and signing. PGP uses RSA and DSA to create
signatures, which are generally accepted standards that pose little risk of
vulnerability.

### In transit

While it is recommended that users use TLS to verify the remote server's
authenticity and to encrypt all data going over the network, this is not a
requirement and so we must consider scenarios in which an attacker can read all
communication between the client and server. In the case that an attacker
intercepts the challenge on its way to the client, she may have the ability to
modify the challenge, use the challenge for herself, or discard the challenge.

If she modifies the challenge, the client will presumably sign and return
whatever it is that the attacker sends in place of the original challenge. If
the data that the attacker coerced the client to sign holds significance, this
may be an issue. The attacker may be able to steal the challenge and use it to
authenticate using an arbitrary key pair, but this does not affect the client
whatsoever, as the challenge is in no way associated with the client at this
point. Lastly, the attacker may discard the challenge, in which case the client
would be unable to authenticate. This requires the assumption that the attacker
has the ability to modify content going through the network.

## Use of GPG

## Server handling of public keys

## Key signatures / web of trust

